
options {
    DEBUG_PARSER = false;
    DEBUG_TOKEN_MANAGER = false;

    STATIC = false;
}

PARSER_BEGIN(SymantaxParser)
package com.semantax.parser.generated;

import com.semantax.ast.factory.*;
import com.semantax.ast.node.*;
import com.semantax.ast.node.list.*;
import com.semantax.ast.node.literal.*;
import com.semantax.ast.node.literal.type.*;
import com.semantax.ast.util.FilePos;

public class SymantaxParser {}

PARSER_END(SymantaxParser)

SKIP: {
    " " | "\t " | "\n" | "\r"
}

// symbols
TOKEN : {
    < BACK_TICK: "`" >
    |
    < TILDE: "~" >
    |
    < BANG: "!" >
    |
    < AT: "@" >
    |
    < HASH: "#" >
    |
    < DOLLAR: "$" >
    |
    < PERCENT: "%" >
    |
    < CARET: "^" >
    |
    < AMPERSAND: "&" >
    |
    < STAR: "*" >
    |
    < DASH: "-" >
    |
    < PLUS: "+" >
    |
    < EQUALS: "=" >
    |
    < L_PAREN: "(" >
    |
    < R_PAREN: ")" >
    |
    < L_BRACE: "{" >
    |
    < R_BRACE: "}" >
    |
    < L_BRACKET: "[" >
    |
    < R_BRACKET: "]" >
    |
    < L_ANGLE: "<" >
    |
    < R_ANGLE: ">" >
    |
    < SEMI_COLON: ";" >
    |
    < COLON: ":" >
    |
    < DOUBLE_QUOTE: "\"" >
    |
    < SINGLE_QUOTE: "'" >
    |
    < COMMA: "," >
    |
    < DOT: "." >
    |
    < ARROW: "->" >
}

// type literals
TOKEN: {
    < TYPE: "type" >
    |
    < INT: "int" >
    |
    < STRING: "string" >
    |
    < BOOL: "bool" >
    |
    < ARRAY: "array" >
    |
    < RECORD: "record" >
    |
    < FUNC: "func" >
}

// keywords
TOKEN: {
    < MODULE: "module" >
    |
    < MODULE_MODIFIER: "public" | "main" >
    |
    < USES: "uses" >
}

// int literals
TOKEN: {
    < DECIMAL_LIT: (["0"-"9"])+ >
    |
    < DOZENAL_LIT: "0d" (["0"-"9", "x", "X", "e", "E"])+ >
}

// bool literals
TOKEN: {
    < TRUE: "true" >
    |
    < FALSE: "false" >
}

// string literals
TOKEN: {
    // A string lit is any escaped character, or anything other than a " or \
    <DOUBLE_QUOTED_STRING: "\"" ("\\" ~[] | ~["\"", "\\"])* "\"" >
    |
    <SINGLE_QUOTED_STRING: "'" ("\\" ~[] | ~["'", "\\"])* "'" >
}


// word
TOKEN: {
    < WORD: <LETTER> (<LETTER> | <DIGIT>)* >
    |
    < #LETTER: ["a"-"z", "A"-"Z"] >
    |
    < #DIGIT: ["0"-"9"] >
}


/** Root production. */
Program Program() :
{
    Module module;
    ModuleList modules = new ModuleList();
}
{
  (module = ModuleDefinition()
    {modules.add(module);}
  )* <EOF>
  {return new Program(modules);}
}

Module ModuleDefinition() :
{
    Token t;
    Word moduleName;
    WordList uses;
    Module subModule;
    ModuleList subModules = new ModuleList();
    Statement statement;
    StatementList statements = new StatementList();
    Module.Builder moduleBuilder = Module.builder();
}
{
    [t = <MODULE_MODIFIER>
     {moduleBuilder.modifier(t.image);}
    ]
    <MODULE>
    moduleName = Word()
    {moduleBuilder.name(moduleName.getValue());}
    [uses = UsesClause()
     {moduleBuilder.modulesUsed(uses);}
    ]
    <L_BRACE>
    (subModule = ModuleDefinition()
     {subModules.add(subModule);}
     |
     statement = Statement()
     {statements.add(statement);}
    )*
    {moduleBuilder.subModules(subModules);
     moduleBuilder.statements(statements);}
    <R_BRACE>
    {Module module = moduleBuilder.build();
     module.setFilePos(moduleName.getFilePos());
     return module;}
}

WordList UsesClause() :
{
    WordList wordList;
}
{
    <USES>
    wordList = WordList()
    {return wordList;}
}

WordList WordList() :
{
    Word word;
    WordList words = new WordList();
}
{
    word = Word()
    {words.add(word);
     words.setFilePos(word.getFilePos());}
    (<COMMA> word = Word()
     {words.add(word);}
    )*
    {return words;}
}

Word Word() :
{
    Token t;
}
{
    t = <WORD>
    {return WordFactory.fromToken(t);}
}

void Symbol() :
{}
{
    <PLUS> | <EQUALS>
}

Statement Statement() :
{
    Expression exp;
}
{
    exp = Expression() <SEMI_COLON>
    {Statement statement = Statement.builder().expression(exp).build();
     statement.setFilePos(exp.getFilePos());
     return statement;}
}

ExpressionList ExpressionList() :
{
    Expression exp;
    ExpressionList expressionList = new ExpressionList();
}
{
    exp = Expression()
    {expressionList.add(exp);
     expressionList.setFilePos(exp.getFilePos());}

    (<COMMA> exp = Expression()
     {expressionList.add(exp);}
    )*
    {return expressionList;}
}

// A single expression followed by a comma, or multiple comma separated expressions
ExpressionList EnforcedExpressionList() :
{
    Expression head;
    ExpressionList tail = null;
    ExpressionList expList = new ExpressionList();
}
{
    head = Expression()
    {expList.add(head);}
    <COMMA>
    [tail = ExpressionList()
    {expList.addAll(tail);}]
    {return expList;}
}

Expression Expression() :
{
    Expression exp;
}
{
    (exp = ProgCall()
    |
    exp = Literal()
    )
    {return exp;}
}

ProgCall ProgCall() :
{
    Word name;
    ExpressionList subExpressions;
    ProgCall.Builder builder = ProgCall.builder();
}
{
    <AT>
    name = Word()
    {builder.name(name.getValue());}
    <L_PAREN>
    [subExpressions = ExpressionList()
     {builder.subExpressions(subExpressions);}
    ]
    <R_PAREN>
    {ProgCall progCall = builder.build();
     progCall.setFilePos(name.getFilePos());
     return progCall;}
}

Literal Literal() :
{
    Literal lit;
}
{
    (lit = PrimitiveLiteral()
    |
    lit = CompoundLiteral()
    |
    lit = TypeLit()
    )
    {return lit;}
}

Literal PrimitiveLiteral() :
{
    Literal lit;
}
{
    (lit = IntLit()
    |
    lit = StringLit()
    |
    lit = BoolLit())
    {return lit;}
}

StringLit StringLit() :
{
    Token t;
}
{
    (t = <DOUBLE_QUOTED_STRING>
    |
    t = <SINGLE_QUOTED_STRING>)
    {return StringLitFactory.fromToken(t);}
}

IntLit IntLit() :
{
    Token t;
}
{
    (t = <DECIMAL_LIT>
    |
    t = <DOZENAL_LIT>)
    {return IntLitFactory.fromToken(t);}
}

BoolLit BoolLit() :
{
    Token t;
}
{
    (t = <TRUE>
    |
    t = <FALSE>)
    {return BoolLitFactory.fromToken(t);}
}

TypeLit TypeLit() :
{
    TypeLit t;
}
{
    (t = SimpleTypeLit()
    |
    t = CompoundTypeLit())
    {return t;}
}

TypeLit SimpleTypeLit() :
{
    Token t;
}
{
    (t = <TYPE>
    |
    t = <INT>
    |
    t = <STRING>
    |
    t = <BOOL>)
    {return TypeLitFactory.fromToken(t);}
}

TypeLit CompoundTypeLit() :
{
    TypeLit t;
}
{
    (t = ArrayTypeLit()
    |
    t = RecordTypeLit()
    |
    t = FuncTypeLit())
    {return t;}
}

// func{} func{->}
// func{A} func{A->}
// func{->B}
// func{A->B}
FuncTypeLit FuncTypeLit() :
{
    Token t;
    TypeLit inputType = null;
    TypeLit outputType = null;
}
{
    t = <FUNC>
    <L_BRACE>
    (
        (<R_BRACE>)
        |
        (<ARROW> [outputType = TypeLit()] <R_BRACE> )
        |
        (inputType = TypeLit() (<R_BRACE> | <ARROW> [outputType = TypeLit()] <R_BRACE> ))
    )
    {FuncTypeLit.Builder builder = FuncTypeLit.builder();
     if (outputType != null) builder.outputType(outputType);
     if (inputType != null) builder.inputType(inputType);
     return builder.buildWith(FilePos.from(t));}
}

ArrayTypeLit ArrayTypeLit() :
{
    Token identifier;
    TypeLit subType;
}
{
    (identifier = <ARRAY>)
    <L_PAREN>
    (subType = TypeLit())
    <R_PAREN>
    {ArrayTypeLit arrayTypeLit = ArrayTypeLit.builder()
        .subType(subType)
        .build();
     arrayTypeLit.setFilePos(FilePos.from(identifier));
     return arrayTypeLit;}
}

RecordTypeLit RecordTypeLit() :
{
    Token identifier;
    NameTypePairList nameTypePairs = new NameTypePairList(); // overwrite this if there is a non-empty list
}
{
    identifier = <RECORD>
    <L_PAREN>
    [nameTypePairs = NameTypePairList()]
    <R_PAREN>
    {RecordTypeLit recordTypeLit = RecordTypeLit.builder()
        .nameTypePairs(nameTypePairs)
        .build();
     recordTypeLit.setFilePos(FilePos.from(identifier));
     return recordTypeLit;}
}

NameTypePair NameTypePair() :
{
    Word name;
    TypeLit type;
}
{
    name = Word()
    <COLON>
    type = TypeLit()
    {NameTypePair nameTypePair = NameTypePair.builder()
        .name(name.getValue())
        .type(type)
        .build();
     nameTypePair.setFilePos(name.getFilePos());
     return nameTypePair;}
}

NameTypePairList NameTypePairList() :
{
    NameTypePair nameTypePair;
    NameTypePairList nameTypePairList = new NameTypePairList();
}
{
    nameTypePair = NameTypePair()
    {nameTypePairList.add(nameTypePair);
     nameTypePairList.setFilePos(nameTypePair.getFilePos());}

    (<COMMA> nameTypePair = NameTypePair()
     {nameTypePairList.add(nameTypePair);}
    )*
    {return nameTypePairList;}
}

NameExpressionPair NameExpressionPair() :
{
    Word name;
    Expression exp;
}
{
    name = Word()
    <COLON>
    exp = Expression()
    {return NameExpressionPair.builder()
        .name(name.getValue())
        .expression(exp)
        .buildWith(name.getFilePos());}
}

NameExpressionPairList NameExpressionPairList() :
{
    NameExpressionPair nameExpressionPair;
    NameExpressionPairList nameExpressionPairList = new NameExpressionPairList();
}
{
    nameExpressionPair = NameExpressionPair()
    {nameExpressionPairList.add(nameExpressionPair);
     nameExpressionPairList.setFilePos(nameExpressionPair.getFilePos());}

    (<COMMA> nameExpressionPair = NameExpressionPair()
     {nameExpressionPairList.add(nameExpressionPair);}
    )*
    {return nameExpressionPairList;}
}

Literal CompoundLiteral() :
{
    Literal lit;
}
{
    (lit = ArrayLit()
    |
    lit = RecordLit())
    {return lit;}
}

ArrayLit ArrayLit() :
{
    Token t;
    ExpressionList expressions = new ExpressionList();
}
{
    t = <L_BRACKET>
    [expressions = EnforcedExpressionList()]
    <R_BRACKET>
    {return ArrayLit.builder()
                .values(expressions)
                .buildWith(FilePos.from(t));}
}

RecordLit RecordLit() :
{
    Token t;
    NameExpressionPairList nameExpressionPairs = new NameExpressionPairList();
}
{
    t = <L_PAREN>
    [nameExpressionPairs = NameExpressionPairList()]
    <R_PAREN>
    {return RecordLit.builder()
        .nameExpressionPairs(nameExpressionPairs)
        .buildWith(FilePos.from(t));}
}
